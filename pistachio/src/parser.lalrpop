//! This module defines the LR(1) grammar for the mustache templating syntax
//! supported by Pistachio.
//!
//! Note: to simplify the production rules and keep things context free,
//! a custom lexer is used - see [`crate::parser::Lexer`].
//!
//! [mustache]: https://jgonggrijp.gitlab.io/wontache/mustache.5.html

use crate::{
    lexer::{Token, Layout},
    parser::{Spanned, balanced, recursive},
    template::{Name, Tag},
    map::Set,
    Loader,
    Error,
};

grammar<'a>(
    size_hint: &mut usize,
    loader: &mut dyn Loader<'a>,
    source: &'a str
);

// Tokens

extern {
    type Location = usize;
    type Error    = Error;

    enum Token<'a> {
        "EOF"     => Token::Eof(<&'a str>, <Layout>),
        "IDENT"   => Token::Ident(<&'a str>),
        "STRING"  => Token::String(<&'a str>),
        "{{"      => Token::Enter(<&'a str>, _),
        "}}"      => Token::Leave(_, <Layout>),
        "&"       => Token::Ampersand,
        "#"       => Token::Hash,
        "^"       => Token::Caret,
        "/"       => Token::RSlash,
        "<"       => Token::LAngle,
        ">"       => Token::RAngle,
        "{"       => Token::LBrace,
        "$"       => Token::Dollar,
        "!"       => Token::Bang,
        "*"       => Token::Asterisk,
        "."       => Token::Period,
        "="       => Token::Equals,
    }
}

// Productions

pub Mustache: Vec<Tag<'a>> = {
    Tags => <>
}

#[inline]
Tags: Vec<Tag<'a>> = {
    Tag+ => <>.into_iter().flatten().collect(),
}

Tag: Vec<Tag<'a>> = {
    Section  => <>,
    Inverted => <>,
    Parent   => <>,
    Block    => <>,
    Partial  => <>,
    Variable => vec![<>],
    Comment  => vec![<>],
    Eof      => vec![<>],
}

Section: Vec<Tag<'a>> = {
    <text:"{{"> "#" <name:Name> <layout:"}}"> <start:@R> <tags:Tags?> <end:@R> <close:Closing> =>? {
        /// XXX: this is pretty atrocious.
        let capture = &source[start + 1 ..end + 1];

        balanced!("#", &name, &close.name, name.span(), {
            Ok(Tag::section(layout.trim(text), name, tags, capture, close))
        })
    },
}

Inverted: Vec<Tag<'a>> = {
    <text:"{{"> "^" <name:Name> <layout:"}}"> <tags:Tags?> <close:Closing> =>? {
        balanced!("^", &name, &close.name, name.span(), {
            Ok(Tag::inverted(layout.trim(text), name, tags, close))
        })
    },
}

Block: Vec<Tag<'a>> = {
    <text:"{{"> "$" <name:Key> <layout:"}}"> <tags:Tags?> <close:Closing> =>? {
        balanced!("$", &name, &close.name, name.span(), {
            Ok(Tag::block(layout.trim(text), name, tags, close))
        })
    },
}

Parent: Vec<Tag<'a>> = {
//     // <text:"{{"> "<" "*" <name:Name> <layout:"}}"> <tags:Tags?> <close:Closing> =>? {
//     //     balanced!("<", &name, &close.key, name.span(), {
//     //         Ok(Tag::dynamic_parent(layout.trim(text), name, tags, close))
//     //     })
//     // },

    <text:"{{"> "<" <start:@L> <path:"STRING"> <layout:"}}"> <tags:Tags?> <close:Closing> =>? {
        let name = Name { start, keys: vec![path] };

        balanced!("<", &name, &close.name, name.span(), {
            let template = loader.get_partial(path.into())?;
            *size_hint += template.size_hint();
            Ok(template.inherit_parent(layout.trim(text), tags, close))
        })
    },
}

Partial: Vec<Tag<'a>> = {
    // <text:"{{"> ">" "*" <name:Name> <layout:"}}"> => {
    //     Tag::dynamic_partial(layout.trim(text), name)
    // },

    <text:"{{"> ">" <start:@L> <path:"STRING"> <layout:"}}"> =>? {
        let template = loader.get_partial(path.into())?;
        *size_hint += template.size_hint();
        Ok(template.to_partial(layout.trim(text)))
    },
}

Closing: Tag<'a> = {
    <text:"{{"> "/" <start:@L> <path:"STRING"> <layout:"}}"> => {
        Tag::closing(layout.trim(text), Name { start, keys: vec![path] })
    },
}

Variable: Tag<'a> = {
    <text:"{{"> "{" <name:Name> "}}" => Tag::unescaped(text, name),
    <text:"{{"> "&" <name:Name> "}}" => Tag::unescaped(text, name),
    <text:"{{">     <name:Name> "}}" => Tag::escaped(text, name),
}

Comment: Tag<'a> = {
    <text:"{{"> "!" String <layout:"}}"> => {
        Tag::content(layout.trim(text))
    },
}

Eof: Tag<'a> = {
    <"EOF"> => {
        let (text, layout) = <>;
        let text = layout.trim(text);
        *size_hint += text.len();
        Tag::content(text)
    },
}

Name: Name<'a> = {
    <start:@L> <head:"IDENT"> <mut keys:("." <"IDENT">)*> => {
        keys.insert(0, head);
        Name { start, keys }
    },

    <start:@L> "." => {
        Name { start, keys: vec!["."] }
    },
}

Key: Name<'a> = {
    <start:@L> <key:"IDENT"> => {
        Name { start, keys: vec![key] }
    },
}

String: &'a str = {
    <"STRING"> => <>.trim_end(),
}
