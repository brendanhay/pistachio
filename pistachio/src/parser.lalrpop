//! This module defines the LR(1) grammar for the mustache templating syntax
//! supported by Pistachio.
//!
//! Note: to simplify the production rules and keep things context free,
//! a custom lexer is used - see [`crate::parser::Lexer`].
//!
//! [mustache]: https://jgonggrijp.gitlab.io/wontache/mustache.5.html

use crate::{
    lexer::Token,
    parser::balanced,
    template::{Key, Node, Name},
    Error,
    Loader,
};

grammar<'a>(size_hint: &mut usize, loader: &mut dyn Loader<'a>, source: &'a str);

// Tokens

extern {
    type Location = usize;
    type Error    = Error;

    enum Token<'a> {
        "IDENT"   => Token::Ident(<&'a str>),
        "STRING"  => Token::String(<&'a str>),
        "CONTENT" => Token::Content(<&'a str>),
        "{{"      => Token::Enter(<&'a str>),
        "}}"      => Token::Leave(<&'a str>),
        "&"       => Token::Ampersand,
        "#"       => Token::Hash,
        "^"       => Token::Caret,
        "/"       => Token::RSlash,
        "<"       => Token::LAngle,
        ">"       => Token::RAngle,
        "{"       => Token::LBrace,
        "$"       => Token::Dollar,
        "!"       => Token::Bang,
        "*"       => Token::Asterisk,
        "."       => Token::Period,
        "="       => Token::Equals,
    }
}

// Productions

pub Mustache: Vec<Node<'a>> = {
    Nodes => <>
}

#[inline]
Nodes: Vec<Node<'a>> = {
    Node+ => <>.into_iter().flatten().collect(),
}

Node: Vec<Node<'a>> = {
    Section  => <>,
    Inverted => <>,
    Parent   => <>,
    Block    => <>,
    Partial  => <>,
    Content  => vec![<>],
    Comment  => vec![],
    Variable => <>,
}

Section: Vec<Node<'a>> = {
    "{{" "#" <name:Name> "}}" <nodes:Nodes> <end:Closing> =>? {
        balanced!("#", &name, end, {
            Ok(name.section(nodes))
        })
    },
}

Inverted: Vec<Node<'a>> = {
    "{{" "^" <name:Name> "}}" <nodes:Nodes> <end:Closing> =>? {
        balanced!("^", &name, end, {
            Ok(name.inverted(nodes))
        })
    },
}

Block: Vec<Node<'a>> = {
    "{{" "$" <key:Key> "}}" <nodes:Nodes> <end:Closing> =>? {
        balanced!("$", &key, end, {
            Ok(Node::new_block(key, nodes))
        })
    },
}

Parent: Vec<Node<'a>> = {
    "{{" "<" "*" <name:Name> "}}" <nodes:Nodes> <end:Closing> =>? {
        balanced!("<", &name, end, {
            Ok(name.parent(nodes))
        })
    },

    "{{" "<" <name:String> "}}" <nodes:Nodes> <end:Closing> =>? {
        balanced!("<", name, end, {
            let parent = loader.get_template(name)?;
            *size_hint += parent.size_hint();
            Ok(parent.inherit(nodes))
        })
    },
}

Partial: Vec<Node<'a>> = {
    "{{" ">" "*" <name:Name> "}}" => {
        name.partial()
    },

    "{{" ">" <name:String> "}}" =>? {
        let partial = loader.get_template(name)?;
        *size_hint += partial.size_hint();
        Ok(partial.include())
    },
}

Closing: &'a str = {
    "{{" "/" <String> "}}" => <>,
}

Variable: Vec<Node<'a>> = {
    "{{" "{" <name:Name> "}}" => name.unescaped(),
    "{{" "&" <name:Name> "}}" => name.unescaped(),
    "{{"     <name:Name> "}}" => name.escaped(),
}

Comment: Option<Node<'a>> = {
    "{{" "!" String "}}" => None,
}

Content: Node<'a> = {
    <start:@L> <text:"CONTENT"> => {
        *size_hint += text.len();
        Node::new_content(start, text)
    },
}

Name: Name<'a> = {
    <head:Key> <tail:("." <Key>)*> => {
        Name::new(head, tail)
    },

    <start:@L> "." => {
        Name::new(Key::dot(start), Vec::new())
    }
}

Key: Key<'a> = {
    <start:@L> <ident:"IDENT"> => Key::new(start, ident),
}

String: &'a str = {
    <"STRING"> => <>.trim_end(),
}
