//! This module defines the LR(1) grammar for the mustache templating syntax
//! supported by Pistachio.
//!
//! Note: to simplify the production rules and keep things context free,
//! a custom lexer is used - see [`crate::parser::Lexer`].
//!
//! [mustache]: https://jgonggrijp.gitlab.io/wontache/mustache.5.html

use crate::{
    lexer::{Token, Layout},
    parser::{Spanned, balanced},
    template::{Name, Tag},
    map::Set,
    Error,
};

grammar<'a>(size_hint: &mut usize, partials: &mut Set<&'a str>, source: &'a str);

// Tokens

extern {
    type Location = usize;
    type Error    = Error;

    enum Token<'a> {
        "EOF"     => Token::Eof(<&'a str>, <Layout>),
        "IDENT"   => Token::Ident(<&'a str>),
        "STRING"  => Token::String(<&'a str>),
        "{{"      => Token::Enter(<&'a str>, _),
        "}}"      => Token::Leave(_, <Layout>),
        "&"       => Token::Ampersand,
        "#"       => Token::Hash,
        "^"       => Token::Caret,
        "/"       => Token::RSlash,
        "<"       => Token::LAngle,
        ">"       => Token::RAngle,
        "{"       => Token::LBrace,
        "$"       => Token::Dollar,
        "!"       => Token::Bang,
        "*"       => Token::Asterisk,
        "."       => Token::Period,
        "="       => Token::Equals,
    }
}

// Productions

pub Mustache: Vec<Tag<'a>> = {
    Tags => <>
}

#[inline]
Tags: Vec<Tag<'a>> = {
    Tag+ => <>.into_iter().flatten().collect(),
}

Tag: Vec<Tag<'a>> = {
    Section  => <>,
    Inverted => <>,
    // Parent   => <>,
    // Block    => <>,
    Partial  => vec![<>],
    Variable => vec![<>],
    Comment  => vec![<>],
    Eof      => vec![<>],
}

Section: Vec<Tag<'a>> = {
    <text:"{{"> "#" <name:Name> <layout:"}}"> <tags:Tags?> <close:Closing> =>? {
        balanced!("#", &name, &close.name, name.span(), {
            Ok(Tag::section(layout.trim(text), name, tags, close))
        })
    },
}

Inverted: Vec<Tag<'a>> = {
    <text:"{{"> "^" <name:Name> <layout:"}}"> <tags:Tags?> <close:Closing> =>? {
        balanced!("^", &name, &close.name, name.span(), {
            Ok(Tag::inverted(layout.trim(text), name, tags, close))
        })
    },
}

// Block: Vec<Tag<'a>> = {
//     <text:"{{"> "$" <name:Key> <layout:"}}"> <tags:Tags?> <close:Closing> =>? {
//         balanced!("$", &name, &close.key, key.span(), {
//             Ok(Tag::block(layout.trim(text), key, tags, close))
//         })
//     },
// }

// Parent: Vec<Tag<'a>> = {
//     <text:"{{"> "<" "*" <name:Name> <layout:"}}"> <tags:Tags?> <close:Closing> =>? {
//         balanced!("<", &name, &close.key, name.span(), {
//             Ok(Tag::dynamic_parent(layout.trim(text), name, tags, close))
//         })
//     },

//     <text:"{{"> "<" <start:@L> <path:Path> <layout:"}}"> <tags:Tags?> <close:ClosePath> =>? {
//         balanced!("<", &name, &close.key, (start, name).span(), {
//             let template = loader.get_template(name)?;
//             *size_hint += template.size_hint();
//             Ok(template.inherit_parent(layout.rim(text), tags, close))
//         })
//     },
// }

Partial: Tag<'a> = {
    // <text:"{{"> ">" "*" <name:Name> <layout:"}}"> => {
    //     Tag::dynamic_partial(layout.trim(text), name)
    // },

    <text:"{{"> ">" <start:@L> <path:"STRING"> <layout:"}}"> =>? {
        partials.insert(path);
        Ok(Tag::partial(layout.trim(text), Name { start, keys: vec![path] }))
    },
}

// Closing: Tag<'a> = {
//     <text:"{{"> "/" <name:Name> <layout:"}}"> => {
//         Tag::closing(layout.trim(text), name)
//     },
// }

Closing: Tag<'a> = {
    <text:"{{"> "/" <start:@L> <path:"STRING"> <layout:"}}"> => {
        Tag::closing(layout.trim(text), Name { start, keys: vec![path] })
    },
}

Variable: Tag<'a> = {
    <text:"{{"> "{" <name:Name> "}}" => Tag::unescaped(text, name),
    <text:"{{"> "&" <name:Name> "}}" => Tag::unescaped(text, name),
    <text:"{{">     <name:Name> "}}" => Tag::escaped(text, name),
}

Comment: Tag<'a> = {
    <text:"{{"> "!" String <layout:"}}"> => {
        Tag::content(layout.trim(text))
    },
}

Eof: Tag<'a> = {
    <"EOF"> => {
        let (text, layout) = <>;
        let text = layout.trim(text);
        *size_hint += text.len();
        Tag::content(text)
    },
}

Name: Name<'a> = {
    <start:@L> <head:"IDENT"> <mut keys:("." <"IDENT">)*> => {
        keys.insert(0, head);
        Name { start, keys }
    },

    <start:@L> "." => {
        Name { start, keys: vec!["."] }
    },
}

Key: Name<'a> = {
    <start:@L> <key:"IDENT"> => {
        Name { start, keys: vec![key] }
    },
}

String: &'a str = {
    <"STRING"> => <>.trim_end(),
}
