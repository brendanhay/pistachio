//! This module defines the LR(1) grammar for the mustache templating syntax
//! supported by Pistachio.
//!
//! Note: to simplify the production rules and keep things context free,
//! a custom lexer is used - see [`crate::parser::Lexer`].
//!
//! [mustache]: https://jgonggrijp.gitlab.io/wontache/mustache.5.html

use crate::{
    lexer::Token,
    parser::balanced,
    template::{Key, Node, Path},
    Error,
    Loader,
};

grammar<'a>(size_hint: &mut usize, loader: &mut dyn Loader<'a>, source: &'a str);

// Tokens

extern {
  type Location = usize;
  type Error    = Error;

  enum Token<'a> {
    "IDENT"   => Token::Ident(<&'a str>),
    "STRING"  => Token::String(<&'a str>),
    "CONTENT" => Token::Content(<&'a str>),
    "{{"      => Token::Enter(<&'a str>),
    "}}"      => Token::Leave(<&'a str>),
    "&"       => Token::Ampersand,
    "#"       => Token::Hash,
    "^"       => Token::Caret,
    "/"       => Token::Slash,
    ">"       => Token::Greater,
    "<"       => Token::Less,
    "$"       => Token::Dollar,
    "!"       => Token::Bang,
    "*"       => Token::Asterisk,
    "."       => Token::Period,
    "="       => Token::Equals,
  }
}

// Productions

pub Mustache: Vec<Node<'a>> = {
    Nodes => <>
}

#[inline]
Nodes: Vec<Node<'a>> = {
    Node+ => <>.into_iter().flatten().collect(),
}

Node: Vec<Node<'a>> = {
    Section  => <>,
    Inverted => <>,
    Parent   => <>,
    Block    => <>,
    Partial  => <>,
    Content  => vec![<>],
    Comment  => vec![],
    Variable => <>,
}

Section: Vec<Node<'a>> = {
    "{{" "#" <path:Path> "}}" <nodes:Nodes> <end:Closing> =>? {
        balanced!("#", &path, end, {
            Ok(path.section(nodes))
        })
    },
}

Inverted: Vec<Node<'a>> = {
    "{{" "^" <path:Path> "}}" <nodes:Nodes> <end:Closing> =>? {
        balanced!("^", &path, end, {
            Ok(path.inverted(nodes))
        })
    },
}

Block: Vec<Node<'a>> = {
    "{{" "$" <key:Key> "}}" <nodes:Nodes> <end:Closing> =>? {
        balanced!("$", &key, end, {
            Ok(Node::block(key, nodes))
        })
    },
}

Parent: Vec<Node<'a>> = {
    "{{" "<" "*" <path:Path> "}}" <nodes:Nodes> <end:Closing> =>? {
        balanced!("<", &path, end, {
            Ok(path.parent(nodes))
        })
    },

    "{{" "<" <name:String> "}}" <nodes:Nodes> <end:Closing> =>? {
        balanced!("<", name, end, {
            let parent = loader.get_template(name)?;
            *size_hint += parent.size_hint;
            Ok(parent.inherit(nodes))
        })
    },
}

Partial: Vec<Node<'a>> = {
    "{{" ">" "*" <path:Path> "}}" => {
        path.partial()
    },

    "{{" ">" <name:String> "}}" =>? {
        let partial = loader.get_template(name)?;
        *size_hint += partial.size_hint();
        Ok(partial.include())
    },
}

Closing: &'a str = {
    "{{" "/" <String> "}}" => <>,
}

Variable: Vec<Node<'a>> = {
    "{{" "&" <path:Path> "}}" => path.unescaped(),
    "{{"     <path:Path> "}}" => path.escaped(),
}

Comment: Option<Node<'a>> = {
    "{{" "!" String "}}" => None,
}

Content: Node<'a> = {
    <start:@L> <text:"CONTENT"> => {
        *size_hint += text.len();
        Node::content(start, text)
    },
}

Path: Path<'a> = {
    <head:Key> <tail:("." <Key>)*> => {
        Path::new(head, tail)
    },

    <start:@L> "." => {
        Path::new(Key::new(start, "<reserved:dot>"), Vec::new())
    }
}

Key: Key<'a> = {
    <start:@L> <ident:"IDENT"> => Key::new(start, ident),
}

String: &'a str = {
    <"STRING"> => <>.trim_end(),
}
